#include <string.h>
#include "delay.h" 	
#include "usart.h"
#include "LB301.h"

u32 LB301Addr = 0XFFFFFFFF; //默认

//初始化PA6为下拉输入		    
//读摸出感应状态(触摸感应时输出高电平信号)
void PS_StaGPIO_Init(void)
{   
	RCC->APB1ENR |= 1<<2;//使能PORTA时钟
	GPIOA->CRL &=0XF0FFFFFF;//复位PA6
	GPIOA->CRL |=0X08000000;//输入模式，默认下拉
	GPIOA->ODR &=~(1<<6);//下拉
}

//串口发送一个字节
static void MYUSART_SendData(u8 data)
{
	while((USART3->SR&0X40)==0); 
	USART3->DR = data;
}
//发送包头
static void SendHead(void)
{
	MYUSART_SendData(0xEF);
	MYUSART_SendData(0x01);
}
//发送地址
static void SendAddr(void)
{
	MYUSART_SendData(LB301Addr>>24);
	MYUSART_SendData(LB301Addr>>16);
	MYUSART_SendData(LB301Addr>>8);
	MYUSART_SendData(LB301Addr);
}
//发送包标识,
static void SendFlag(u8 flag)
{
	MYUSART_SendData(flag);
}
//发送包长度
static void SendLength(int length)
{
	MYUSART_SendData(length>>8);
	MYUSART_SendData(length);
}
//发送指令码
static void Sendcmd(u8 cmd)
{
	MYUSART_SendData(cmd);
}
//发送校验和
static void SendCheck(u16 check)
{
	MYUSART_SendData(check>>8);
	MYUSART_SendData(check);
}
//等待应答
//waittime：等待超时时间（单位1ms）
//返回接收数组的首地址
static u8 *WaitBack(u16 waittime)
{
	char *data;
	u8 str[8];
	str[0]=0xef;					str[1]=0x01;
	str[2]=LB301Addr>>24;	str[3]=LB301Addr>>16;		
	str[4]=LB301Addr>>8;	str[5]=LB301Addr;				
	str[6]=0x07;					str[7]='\0';
	USART3_RX_STA=0;
	while(--waittime)
	{
		delay_ms(1);
		if(USART3_RX_STA&0X8000)//接收到一次数据
		{
			data=strstr((const char*)USART3_RX_BUF,(const char*)str);
			if(data)
				return (u8*)data;	
		}
	}
	return 0;
}
//录入图像 PS_GetImage
//功能:探测手指，探测到后录入指纹图像存于ImageBuffer。 
//模块返回确认字
u8 PS_GetImage(void)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x03);
	Sendcmd(0x01);
	temp =  0x01+0x03+0x01;
	SendCheck(temp);
	data=WaitBack(500);//等待返回（ms超时机制）
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//生成特征 PS_GenChar
//功能:将ImageBuffer中的原始图像生成指纹特征文件存于CharBuffer1\2\3\4		 
//参数:BufferID --> charBuffer1:0x01 0x02 0x03 0x04	  											
//模块返回确认字
u8 PS_GenChar(u8 BufferID)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x04);
	Sendcmd(0x02);
	MYUSART_SendData(BufferID);
	temp = 0x01+0x04+0x02+BufferID;
	SendCheck(temp);
	data=WaitBack(500); //这条指令回复时间有点满 至少大于100ms
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//搜索指纹 PS_Search
//功能:以CharBuffer1或CharBuffer2中的特征文件搜索整个或部分指纹库.若搜索到，则返回页码。			
//参数:  BufferID @ref CharBuffer1	CharBuffer2
//说明:  模块返回确认字，页码（相配指纹模板）
u8 PS_Search(u8 BufferID,u16 StartPage,u16 PageNum,SearchResult *p)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x08);
	Sendcmd(0x04);
	MYUSART_SendData(BufferID);
	MYUSART_SendData(StartPage>>8);
	MYUSART_SendData(StartPage);
	MYUSART_SendData(PageNum>>8);
	MYUSART_SendData(PageNum);
	temp = 0x01+0x08+0x04+BufferID
	+(StartPage>>8)+(u8)StartPage
	+(PageNum>>8)+(u8)PageNum;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
	{
		ensure = data[9];
		p->pageID   =(data[10]<<8)+data[11];
		p->mathscore=(data[12]<<8)+data[13];	
	}
	else
		ensure = 0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;	
}
//合并特征（生成模板）PS_RegMB
//功能:将CharBuffer1与CharBuffer2中的特征文件合并生成 模板,结果存于CharBuffer1与CharBuffer2	
//说明:  模块返回确认字
u8 PS_RegMB(void)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x03);
	Sendcmd(0x05);
	temp = 0x01+0x03+0x05;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;		
}
//储存模板 PS_StoreMB
//功能:将 CharBuffer1 或 CharBuffer2 中的模板文件存到 PageID 号flash数据库位置。			
//参数:  BufferID @ref charBuffer1:0x01	charBuffer1:0x02
//       PageID（指纹库位置号）
//说明:  模块返回确认字
u8 PS_StoreMB(u8 BufferID,u16 PageID)
{
	u16 temp;
  u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x06);
	Sendcmd(0x06);
	MYUSART_SendData(BufferID);
	MYUSART_SendData(PageID>>8);
	MYUSART_SendData(PageID);
	temp = 0x01+0x06+0x06+BufferID
	+(PageID>>8)+(u8)PageID;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;	
}
//删除模板 PS_DeletChar
//功能:  删除flash数据库中指定ID号开始的N个指纹模板
//参数:  PageID(指纹库模板号)，N删除的模板个数。
//说明:  模块返回确认字
u8 PS_DeletChar(u16 PageID,u16 N)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x07);
	Sendcmd(0x0C);
	MYUSART_SendData(PageID>>8);
	MYUSART_SendData(PageID);
	MYUSART_SendData(N>>8);
	MYUSART_SendData(N);
	temp = 0x01+0x07+0x0C
	+(PageID>>8)+(u8)PageID
	+(N>>8)+(u8)N;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//清空指纹库 PS_Empty
//功能:  删除flash数据库中所有指纹模板
//参数:  无
//说明:  模块返回确认字
u8 PS_Empty(void)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x03);
	Sendcmd(0x0D);
	temp = 0x01+0x03+0x0D;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
		ensure=data[9];
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//读系统基本参数 PS_ReadSysPara
//功能:  读取模块的基本参数（波特率，包大小等)
//参数:  无
//说明:  模块返回确认字 + 基本参数（16bytes）
u8 PS_ReadSysPara(SysPara *p)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x03);
	Sendcmd(0x0F);
	temp = 0x01+0x03+0x0F;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
	{
		ensure = data[9];
		p->PS_max = (data[15]<<8)+data[14];
		p->PS_level = (data[17]<<8)+data[16];
		p->PS_addr=(data[18]<<24)+(data[19]<<16)+(data[20]<<8)+data[21];
		p->PS_size = (data[23]<<8)+data[22];
		p->PS_N = (data[25]<<8)+data[24];
	}		
	else
		ensure=0xff;
	if(ensure==0x00)
	{
		printf("\r\n模块最大指纹容量=%d",p->PS_max);
		printf("\r\n对比等级=%d",p->PS_level);
		printf("\r\n地址=%x",p->PS_addr);
		printf("\r\n波特率=%d",p->PS_N*9600);
	}
	else 
		printf("\r\n%s",EnsureMessage(ensure));
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//自动验证指纹 PS_AutoIdentify
//功能:自动采集指纹，在指纹库搜索匹配的模板，返回搜索结果。			 												
//模块返回确认字
u8 PS_AutoIdentify(SearchResult *p)
{
#define  SEC_LEVEL		0X03	//安全等级
#define  S_ID			0XFFFF  //ID号，0XFFFF表示搜索整个库
#define  S_PARAM		0X0007  //参数，bit0 LED亮灭  bit1 图像预处理 bit2 中途是否应答
	
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x08);
	Sendcmd(0x32);
	MYUSART_SendData(SEC_LEVEL);//安全等级
	MYUSART_SendData(S_ID>>8);  //ID号
	MYUSART_SendData((u8)S_ID);
	MYUSART_SendData(S_PARAM>>8);//参数
	MYUSART_SendData((u8)S_PARAM);
	temp = 0x01+0x08+0x32+SEC_LEVEL \
	+(S_ID>>8)+(u8)S_ID+(S_PARAM>>8)+(u8)S_PARAM;
	SendCheck(temp);
	data=WaitBack(40);//无手指，验证不成功时没有返回，所以这里超时时间尽量小
	if(data)
	{
		ensure=data[9];
		p->pageID 	=(data[11]<<8) +data[12];
		p->mathscore=(data[13]<<8) +data[14];
	}
	else
		ensure=0xff;
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}
//读有效模板个数 PS_ValidTempleteNum
//功能：读有效模板个数
//参数: 无
//说明: 模块返回确认字+有效模板个数ValidN
u8 PS_ValidTempleteNum(u16 *ValidN)
{
	u16 temp;
	u8  ensure;
	u8  *data;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x03);
	Sendcmd(0x1d);
	temp = 0x01+0x03+0x1d;
	SendCheck(temp);
	data=WaitBack(500);
	if(data)
	{
		ensure=data[9];
		*ValidN = (data[10]<<8) +data[11];
	}		
	else
		ensure=0xff;
	
	if(ensure==0x00)
	{
		printf("\r\n有效指纹个数=%d",(data[10]<<8)+data[11]);
	}
	else
		printf("\r\n%s",EnsureMessage(ensure));
	memset(USART3_RX_BUF,0,USART3_RX_STA&0x7fff); //数据清0
	USART3_RX_STA = 0;
	return ensure;
}

//修改波特率 PS_FingerMoudleSet  注意：设置后模块立即生效 需重新配置串口波特率才能通讯
//功能:  写模块设置（修改波特率）
//参数:  设置序号RegNum:4
//说明:  模块返回确认字
u8 PS_FingerMoudleSet(u8 N)
{
	u16 temp;
	SendHead();
	SendAddr();
	SendFlag(0x01);//命令包标识
	SendLength(0x05);
	Sendcmd(0x0E);
	MYUSART_SendData(0x04);
	MYUSART_SendData(N);
	temp = 0x04+N+0x01+0x05+0x0E;
	SendCheck(temp);//设置后模块立即生效 
	return 0;
}
//模块应答包确认码信息解析
//功能：解析确认码错误信息返回信息
//参数: ensure
const char *EnsureMessage(u8 ensure) 
{
	const char *p;
	switch(ensure)
	{
		case  0x00:
			p="OK";break;		
		case  0x01:
			p="数据包接收错误";break;
		case  0x02:
			p="No finger on the sensor!";break;
		case  0x03:
			p="录入指纹图像失败";break;
		case  0x04:
			p="指纹图像太干、太淡而生不成特征";break;
		case  0x05:
			p="指纹图像太湿、太糊而生不成特征";break;
		case  0x06:
			p="指纹图像太乱而生不成特征";break;
		case  0x07:
			p="指纹图像正常，但特征点太少（或面积太小）而生不成特征";break;
		case  0x08:
			p="指纹不匹配";break;
		case  0x09:
			p="No fingerprint found!";break;
		case  0x0a:
			p="特征合并失败";break;
		case  0x0b:
			p="ID超出指纹库范围";
		case  0x0c:
			p="从指纹库读模板出错或无效";
		case  0x0d:
			p="上传特征失败";
		case  0x0e:
			p="模块不能接受后续数据包";
		case  0x0f:
			p="上传图像失败";
		case  0x10:
			p="删除模板失败";break;
		case  0x11:
			p="清空指纹库失败";break;
		case  0x12:
			p="不能进入低功耗状态";break;
		case  0x13:
			p="口令不正确";break;
		case  0x14:
			p="系统复位失败";break;			
		case  0x15:
			p="缓冲区内没有有效原始图而生不成图像";break;
		case  0x16:
			p="在线升级失败";break;
		case  0x17:
			p="残留指纹或两次采集之间手指没有移动过";break;
		case  0x18:
			p="读写 FLASH 出错";break;
		case  0x19:
			p="未定义错误";break;
		case  0x1a:
			p="无效寄存器号";break;
		case  0x1b:
			p="寄存器设定内容错误";break;
		case  0x1c:
			p="记事本页码指定错误";break;
		case  0x1e:
			p="自动注册失败";break;
		case  0x1f:
			p="指纹库满";break;
		case  0x20:
			p="地址错误";break;
		case  0x23:
			p="指纹模板为空";break;
		case  0x24:
			p="Fingerprint library is empty";break;
		case  0x26:
			p="自动注册超时";break;
		case  0x27:
			p="自动注册指纹已存在";break;
		default :
			p="模块返回确认码有误";break;
	}
 return p;	
}





